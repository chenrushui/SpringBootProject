1)时间类型：日期date(年月日),datetime(精确到秒),timestamp(表示范围小),一般都是使用datetime
2)数据库设计五个保留字段，不能为空
3)not null不一定会给默认值，需要用户插入值。
4)如果一个查询能够确定只有一个结果，一定要使用limit 1，避免全表扫描。在mapper中使用limit关键字和有效关键字，delete_flag=1
5)在映射文件中，一定要进行入参判断，否者可能出现非预期结果。
6)为什么要删除那些没有用到的方法和映射文件中的sql结点？有些东西永远不会调用的，比如物理删除，肯定不会用的，所以为了代码整洁和可读性，可以删除。
7)insert()与insertSelective()方法的区别：是否判断空值？如果为空，是否插入？插入之前先检查是否为空。
8)端口占用：netstat -ano
9)主从复制，读写分离，分表分库。
10)选择正确的数据类型对于获得高性能很有帮助，就选择你认为不会超出范围的最小类型。为什么占的字节越小越好？每种数据类型，所需要的存储空间不同。
11)bigint,tinyint(0-255),使用int类型表示id可能会出现数据溢出。varchar类型可以存储很多个字符串，比如问题、答案等
12)in在某集合内; between在某范围内
13)列名，下划线命名法；表名也是
14)不用为每一个varchar类型单独定义字符集和排序规则，只需要在表中定义即可。
15)mybatis的参数为集合；进行for循环遍历？
16)CollectionUtils.isEmpty()：查看实现类的isEmpty()方法实现。如果集合为空，创建一个空的集合的经典代码。Collections类
17)post请求，参数使用@RequestParam()注解，表单提交；使用@RequestBody)注解,以json形式提交；get请求，参数为list；
18)Date currentTimes = new Date(); 声明一个时间变量，能够复用，本质上是当前时间毫秒值。
19)数据库设计五个保留字段，时间不能为null，如果插入的时候不设置，就会报错。
20)mybatis接口如何返回一个Map<String,String> map?  select hospital_id as hospitalId, count(1) as num from...
21)传递一个集合查询，必须要进行分组才行？
22)@ApiModel,@ApiModelProperty("医生id") 这两个注解怎么没用啊？如何在生产环境禁用swagger2?
23)@Value取赋值详解与@ConfigurationProperties对比,直接可以取值，不需要先决条件。
24)@EnableDiscoveryClient与@EnableEurekaClient这两个注解的区别是什么？
25)spring MVC是对servlet的封装，mybatis是对jdbc的封装，spring是企业级应用程序开发框架。
26)多个线程同时操作某个数据资源，可以手动设置隔离级别。
27)事务并发会造成脏读，不可重复读，幻读等问题，通过设置事务的隔离解救可以解决这些问题；设置事务的隔离级别本质上是使用mysql的锁机制。
28)表锁行锁是有不同的数据库引擎提供的。
29)什么情况下会造成索引失效？如何避免索引失效？
30)heap,stack,grep文本搜索工具，amqp高级消息队列协议
31)spring cloud组件的使用方式：创建微服务工程，配置文件常用配置，使用注解开启功能(每个组件的配置都不一样，同一个微服务启动多个实例建立集群)
32)映射文件中，sql语句以关键字为分割，换行书写，可读性更好。
33)@FeignClient(value="微服务名称") @EnableFeignClients注解  client，接口名：xxxServiceClient。
34)获取注解对象(getAnnotation(Test.class))，从注解对象上获取用户设定的属性值；通过反射获取对应的类对象，方法对象， 字段对象。定义注解时使用运行时生命周期，否则注解对象为空。
35)学会注解对理解项目中常用的注解，有什么影响？
36)利用反射技术，通过pojo上的注解，创建数据表字段。获取字段的名称，属性，长度。终于理解了这个原理。
37)Class对象是对类信息的封装，注解信息，方法信息等都可以从class对象上获取到。
38)判断是否可以获取到注解对象，如果生命周期不是运行时注解，自定义的注解对象为空。 注解的使用流程：定义注解，使用注解，解析注解。
39)利用反射技术获取对注解对象。
40)对集合进行forEach()遍历，然后使用lambda进行写，能够简化代码，但是可读性不好。
41)ApplicationContext的继承关系，两个子类；通过加载配置文件创建对象。
42)原型模式，本质，分类，优点(保护性copy，解决创建复杂对象的资源消耗问题)，缺点，使用场景
43)@Params注解：相当于包装了map集合的键。
44)代理模式，InvocationHandler接口中的invoke方法；在构造函数中传递接口类型的对象；Proxy.newProxyInstance()
45)MethodInterceptor,Enhancer,拦截所有父类方法的调用
46)尽量使用声明式配置来进行软件的配置，简化代码的实现；配置信息和代码的分离；配置信息统一进行管理维护。
47)mybatis核心配置文件中，常用配置是以键值对的形式存在的。<settings><setting>
48)全局配置文件中，数据源的配置，就那么4项；mybatis的配置 ,写的多了就会了。
49)死锁问题:不释放自己的资源，还要尝试获取别的资源的锁。对锁的理解：如果是同一把锁，就锁定代码，其他线程不能访问；如果不是同一把锁，就可以访问资源，不受影响。核心：是否是同一把锁。
50)如何在springBoot中创建定时任务？定时方法，两个注解的使用，cron表达式以及通配符
51)分布式，高并发，多线程。分布式的实现形式：水平扩展和垂直拆分。单一物理服务器容量和性能瓶颈，如何应对海量数据，cpu资源调度。
52)分布式的实现形式有哪些？  以后就使用Axure进行图片绘制。模块之间的关联关系。
53)如何建立高可用的配置管理中心？如何建立高可用的服务注册中心？项目架构图，如何画？
54)微服务整体架构图? 听的教程里面有的，还没有画。 没有对项目的整体认识，架构图不好画，但是确实是能力的体现(努力的方向)
55)网上有成熟的项目架构图。项目架构图一般都是从上到下画的。横向一般是路程图。
56)mysql中 in关键字支持索引；编写一个sql语句，看看执行计划。explain select * from p_doctor where hospital_id in (105933,12682,144362,475838,849,228,1,2,3,5,4,8)
57)如何进行反编译？classes.dex如何转化成jar文件？jar文件如何查看其中的.java文件。dex2jar：把dex文件转成jar文件.jd-gui工具。
58)字符串拼接:+和StringBuffer的性能比较，StringBuffer性能好一些，不会创建新的String对象。
59)jvm: 项目中可能有多个虚拟机实例，或者说多个虚拟机进程;  每次运行一个项目，都会启动一个jvm虚拟机实例。
60)分布式配置中心: 一个服务如何从配置中心读取文件，配置中心如何从远程git读取配置文件；
61)高可用的分布式配置中心: 当服务实例很多时，都从配置中心读取文件，这时可以考虑将配置中心做成一个微服务，将其集群化，从而达到高可用。
62)https://gitbook.cn/ 项目架构资源。
63)异常处理机制：捕获异常，处理异常。（手动处理异常，不要抛出来就不管了）
64)服务注册中心：向注册中心注册自己，以便别人能够通过名称调用当前微服务。为什么要注册自己啊？
65)需要理解一个算法背后的思想，才能以不变应万变。(常用的算法和数据结构)
66)Feign组件的使用：@FeignClient注解；当前微服务对外暴露接口，feign接口中的方法调用@Controller中的方法；谁要调用当前微服务的功能，需要添加当前微服务的jar包依赖。
67)对外暴露接口，直接使用feign接口就行；但是别人要调用我们的微服务，需要添加依赖，并且注入微服务实例才行。
68)spring.application.name 配置的微服务的名称；通过微服务的名称调用微服务中的方法。
69)微服务名称的命名规范:三级命名法+端口号。
70)api的命名规范：/service-name/apiName/v1/users/zhangsan/age  应用名称/api名称/api版本号/具体接口名称。
71)module的继承关系：直接使用spring init创建项目不存在项目继承，不能使用这个。只用项目继承关系，包自己从新添加就好了。
72)jackson框架的使用，ObjectMapper类，readValue() writeValueAsString() 用于序列化与反序列化的操作.jackson框架的常用配置。
73)使用beanUtils类的好处是什么？BeanUtils.copyProperties() 提高bean复制的效率.
74)server.context-path=/doctor  配置项目的访问路径。
75)SpringBoot项目中，如果已经有spring-boot-dependencies依赖了，所有org.springframework.boot组的依赖都不用添加版本号。




